package com.albunyaan.tube.data.extractor

data class VideoTrack(
    val url: String,
    val mimeType: String?,
    val width: Int?,
    val height: Int?,
    val bitrate: Int?,
    val qualityLabel: String?,
    val fps: Int?,
    val isVideoOnly: Boolean
)

data class AudioTrack(
    val url: String,
    val mimeType: String?,
    val bitrate: Int?,
    val codec: String?
)

data class SubtitleTrack(
    val url: String,
    val languageCode: String,
    val languageName: String,
    val format: String?, // e.g., "vtt", "srt"
    val isAutoGenerated: Boolean = false
)

data class ResolvedStreams(
    val streamId: String,
    val videoTracks: List<VideoTrack>,
    val audioTracks: List<AudioTrack>,
    val subtitleTracks: List<SubtitleTrack> = emptyList(),
    val durationSeconds: Int?,
    /** HLS manifest URL for adaptive streaming (preferred for long videos) */
    val hlsUrl: String? = null,
    /** DASH manifest URL for adaptive streaming (alternative to HLS) */
    val dashUrl: String? = null
)

/**
 * Represents the origin of a quality selection.
 */
enum class QualitySelectionOrigin {
    /** System default - no user preference expressed */
    AUTO,
    /** User manually selected a quality (cap/ceiling) */
    MANUAL,
    /** Automatic recovery action (stall step-down) - does NOT set manual cap */
    AUTO_RECOVERY
}

data class PlaybackSelection(
    val streamId: String,
    val video: VideoTrack?,
    val audio: AudioTrack,
    val resolved: ResolvedStreams,
    /**
     * User's manually selected quality cap (ceiling). When set, playback should not
     * exceed this resolution. ABR can drop below when network dips, then recover up to cap.
     *
     * null = AUTO mode (no cap, ABR chooses freely)
     * non-null = User preference for maximum resolution height
     */
    val userQualityCapHeight: Int? = null,
    /**
     * The origin of the current selection. Used to distinguish manual user choices
     * from automatic recovery actions.
     */
    val selectionOrigin: QualitySelectionOrigin = QualitySelectionOrigin.AUTO
) {
    /**
     * For backward compatibility: returns true if user has manually set a quality cap.
     * Use this when deciding whether to apply track selector constraints.
     */
    val hasUserQualityCap: Boolean
        get() = userQualityCapHeight != null
}

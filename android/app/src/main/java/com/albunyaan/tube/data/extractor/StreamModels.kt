package com.albunyaan.tube.data.extractor

import android.os.SystemClock

/**
 * Metadata required for synthetic DASH MPD generation.
 * Stored from NewPipe's ItagItem during extraction.
 */
data class SyntheticDashMetadata(
    val itag: Int,
    val initStart: Long,
    val initEnd: Long,
    val indexStart: Long,
    val indexEnd: Long,
    val approxDurationMs: Long?,
    val codec: String?
) {
    /**
     * Check if this metadata has valid byte ranges for synthetic DASH.
     */
    fun hasValidRanges(): Boolean =
        initStart >= 0 && initEnd >= 0 && initStart <= initEnd &&
        indexStart >= 0 && indexEnd >= 0 && indexStart <= indexEnd
}

data class VideoTrack(
    val url: String,
    val mimeType: String?,
    val width: Int?,
    val height: Int?,
    val bitrate: Int?,
    val qualityLabel: String?,
    val fps: Int?,
    val isVideoOnly: Boolean,
    /** Metadata for synthetic DASH generation (null if not eligible) */
    val syntheticDashMetadata: SyntheticDashMetadata? = null
)

data class AudioTrack(
    val url: String,
    val mimeType: String?,
    val bitrate: Int?,
    val codec: String?,
    /** Metadata for synthetic DASH generation (null if not eligible) */
    val syntheticDashMetadata: SyntheticDashMetadata? = null
)

data class SubtitleTrack(
    val url: String,
    val languageCode: String,
    val languageName: String,
    val format: String?, // e.g., "vtt", "srt"
    val isAutoGenerated: Boolean = false
)

data class ResolvedStreams(
    val streamId: String,
    val videoTracks: List<VideoTrack>,
    val audioTracks: List<AudioTrack>,
    val subtitleTracks: List<SubtitleTrack> = emptyList(),
    val durationSeconds: Int?,
    /** HLS manifest URL for adaptive streaming (preferred for long videos) */
    val hlsUrl: String? = null,
    /** DASH manifest URL for adaptive streaming (alternative to HLS) */
    val dashUrl: String? = null,
    /**
     * Monotonic timestamp when the stream URLs were generated (SystemClock.elapsedRealtime).
     * Uses monotonic time to avoid issues with user clock changes.
     * YouTube stream URLs typically expire after ~6 hours, but we use a conservative
     * 1-hour TTL to ensure quality switches use fresh URLs.
     */
    val urlGeneratedAt: Long = SystemClock.elapsedRealtime(),
    /**
     * Version marker for the urlGeneratedAt timebase.
     * Bump if the time source changes to avoid comparing incompatible timestamps.
     */
    val urlTimebaseVersion: Int = URL_TIMEBASE_VERSION
) {
    companion object {
        /**
         * Conservative URL TTL: 1 hour (YouTube typically allows ~6 hours).
         * Using a shorter TTL ensures we refresh URLs before they expire,
         * preventing playback failures during quality switches.
         */
        const val URL_TTL_MS = 60 * 60 * 1000L // 1 hour
        /** Timebase version for urlGeneratedAt timestamps. */
        const val URL_TIMEBASE_VERSION = 1
    }

    /**
     * Check if the stream URLs are likely expired based on urlGeneratedAt.
     * Uses monotonic time (SystemClock.elapsedRealtime) to avoid issues with
     * user clock changes that could cause false expiry. If the clock moves
     * backwards (e.g., process restore with stale data), treat URLs as expired.
     * @param nowMs Current monotonic time in milliseconds (default: SystemClock.elapsedRealtime())
     * @return true if URLs are likely expired and should be refreshed
     */
    fun areUrlsExpired(nowMs: Long = SystemClock.elapsedRealtime()): Boolean {
        if (urlTimebaseVersion != URL_TIMEBASE_VERSION) return true
        if (nowMs < urlGeneratedAt) return true
        return (nowMs - urlGeneratedAt) > URL_TTL_MS
    }
}

/**
 * Represents the origin of a quality selection.
 */
enum class QualitySelectionOrigin {
    /** System default - no user preference expressed */
    AUTO,
    /** User manually selected a quality (cap/ceiling) */
    MANUAL,
    /** Automatic recovery action (stall step-down) - does NOT set manual cap */
    AUTO_RECOVERY
}

data class PlaybackSelection(
    val streamId: String,
    val video: VideoTrack?,
    val audio: AudioTrack,
    val resolved: ResolvedStreams,
    /**
     * User's manually selected quality cap (ceiling). When set, playback should not
     * exceed this resolution. ABR can drop below when network dips, then recover up to cap.
     *
     * null = AUTO mode (no cap, ABR chooses freely)
     * non-null = User preference for maximum resolution height
     */
    val userQualityCapHeight: Int? = null,
    /**
     * The origin of the current selection. Used to distinguish manual user choices
     * from automatic recovery actions.
     */
    val selectionOrigin: QualitySelectionOrigin = QualitySelectionOrigin.AUTO
) {
    /**
     * For backward compatibility: returns true if user has manually set a quality cap.
     * Use this when deciding whether to apply track selector constraints.
     */
    val hasUserQualityCap: Boolean
        get() = userQualityCapHeight != null
}

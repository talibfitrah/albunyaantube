package com.albunyaan.tube.data.extractor

import android.os.SystemClock

/**
 * Metadata required for synthetic DASH MPD generation.
 * Stored from NewPipe's ItagItem during extraction.
 */
data class SyntheticDashMetadata(
    val itag: Int,
    val initStart: Long,
    val initEnd: Long,
    val indexStart: Long,
    val indexEnd: Long,
    val approxDurationMs: Long?,
    val codec: String?
) {
    /**
     * Check if this metadata has valid byte ranges for synthetic DASH.
     */
    fun hasValidRanges(): Boolean =
        initStart >= 0 && initEnd >= 0 && initStart <= initEnd &&
        indexStart >= 0 && indexEnd >= 0 && indexStart <= indexEnd
}

data class VideoTrack(
    val url: String,
    val mimeType: String?,
    val width: Int?,
    val height: Int?,
    val bitrate: Int?,
    val qualityLabel: String?,
    val fps: Int?,
    val isVideoOnly: Boolean,
    /** Metadata for synthetic DASH generation (null if not eligible) */
    val syntheticDashMetadata: SyntheticDashMetadata? = null,
    /**
     * Codec string (e.g., "avc1.64001f", "vp9", "av01.0.05M.08").
     * Always populated from NewPipe's stream.codec when available.
     * Use this for codec detection instead of syntheticDashMetadata.codec
     * since syntheticDashMetadata may be null for muxed/HLS/DASH streams.
     */
    val codec: String? = null
)

data class AudioTrack(
    val url: String,
    val mimeType: String?,
    val bitrate: Int?,
    val codec: String?,
    /** Metadata for synthetic DASH generation (null if not eligible) */
    val syntheticDashMetadata: SyntheticDashMetadata? = null
)

data class SubtitleTrack(
    val url: String,
    val languageCode: String,
    val languageName: String,
    val format: String?, // e.g., "vtt", "srt"
    val isAutoGenerated: Boolean = false
)

data class ResolvedStreams(
    val streamId: String,
    val videoTracks: List<VideoTrack>,
    val audioTracks: List<AudioTrack>,
    val subtitleTracks: List<SubtitleTrack> = emptyList(),
    val durationSeconds: Int?,
    /** HLS manifest URL for adaptive streaming (preferred for long videos) */
    val hlsUrl: String? = null,
    /** DASH manifest URL for adaptive streaming (alternative to HLS) */
    val dashUrl: String? = null,
    /** Whether this is a live stream (LIVE_STREAM or AUDIO_LIVE_STREAM) */
    val isLive: Boolean = false,
    /**
     * Monotonic timestamp when the stream URLs were generated (SystemClock.elapsedRealtime).
     * Uses monotonic time to avoid issues with user clock changes.
     * YouTube stream URLs typically expire after ~6 hours, but we use a conservative
     * 1-hour TTL to ensure quality switches use fresh URLs.
     */
    val urlGeneratedAt: Long = SystemClock.elapsedRealtime(),
    /**
     * Version marker for the urlGeneratedAt timebase.
     * Bump if the time source changes to avoid comparing incompatible timestamps.
     */
    val urlTimebaseVersion: Int = URL_TIMEBASE_VERSION
) {
    companion object {
        /**
         * Conservative URL TTL: 1 hour (YouTube typically allows ~6 hours).
         * Using a shorter TTL ensures we refresh URLs before they expire,
         * preventing playback failures during quality switches.
         */
        const val URL_TTL_MS = 60 * 60 * 1000L // 1 hour

        /**
         * For live streams, proactively refresh URLs before they expire.
         * This allows fetching new URLs in the background while playback continues,
         * enabling seamless handoff without interruption.
         *
         * Set to 50 minutes - gives 10 minutes buffer before the 1-hour TTL.
         */
        const val LIVE_PROACTIVE_REFRESH_MS = 50 * 60 * 1000L // 50 minutes

        /** Timebase version for urlGeneratedAt timestamps. */
        const val URL_TIMEBASE_VERSION = 1
    }

    /**
     * Check if the stream URLs are likely expired based on urlGeneratedAt.
     * Uses monotonic time (SystemClock.elapsedRealtime) to avoid issues with
     * user clock changes that could cause false expiry. If the clock moves
     * backwards (e.g., process restore with stale data), treat URLs as expired.
     * @param nowMs Current monotonic time in milliseconds (default: SystemClock.elapsedRealtime())
     * @return true if URLs are likely expired and should be refreshed
     */
    fun areUrlsExpired(nowMs: Long = SystemClock.elapsedRealtime()): Boolean {
        if (urlTimebaseVersion != URL_TIMEBASE_VERSION) return true
        if (nowMs < urlGeneratedAt) return true
        return (nowMs - urlGeneratedAt) > URL_TTL_MS
    }

    /**
     * For live streams, check if we should proactively refresh URLs before expiration.
     * This allows fetching new URLs in the background for seamless handoff.
     * @param nowMs Current monotonic time in milliseconds
     * @return true if this is a live stream and URLs should be proactively refreshed
     */
    fun shouldProactivelyRefresh(nowMs: Long = SystemClock.elapsedRealtime()): Boolean {
        if (!isLive) return false
        if (urlTimebaseVersion != URL_TIMEBASE_VERSION) return true
        if (nowMs < urlGeneratedAt) return true
        return (nowMs - urlGeneratedAt) > LIVE_PROACTIVE_REFRESH_MS
    }

    /**
     * Time remaining until proactive refresh is needed (for live streams).
     * Returns null for non-live streams, or 0L if refresh is already needed.
     */
    fun timeUntilProactiveRefreshMs(nowMs: Long = SystemClock.elapsedRealtime()): Long? {
        if (!isLive) return null
        if (urlTimebaseVersion != URL_TIMEBASE_VERSION) return 0L
        if (nowMs < urlGeneratedAt) return 0L
        val elapsed = nowMs - urlGeneratedAt
        val remaining = LIVE_PROACTIVE_REFRESH_MS - elapsed
        return if (remaining > 0) remaining else 0L
    }
}

/**
 * Represents the origin of a quality selection.
 */
enum class QualitySelectionOrigin {
    /** System default - no user preference expressed */
    AUTO,
    /** User manually selected a quality (cap/ceiling) */
    MANUAL,
    /** Automatic recovery action (stall step-down) - does NOT set manual cap */
    AUTO_RECOVERY
}

/**
 * Phase 3: Quality constraint mode.
 *
 * Defines how user quality selection affects ABR behavior:
 * - CAP: Maximum ceiling; ABR can drop below but not exceed
 * - LOCK: Fixed quality; no ABR switching allowed
 */
enum class QualityConstraintMode {
    /**
     * Quality Cap (ceiling).
     *
     * User selected quality is the maximum allowed resolution.
     * ABR can drop to lower qualities on network congestion and recover up to cap.
     * Use case: "I don't want to exceed 720p to save data"
     */
    CAP,

    /**
     * Quality Lock (fixed).
     *
     * User selected quality is locked - no ABR switching.
     * Player stays at this resolution regardless of network conditions.
     * Use case: "I want exactly 1080p, even if it buffers"
     */
    LOCK
}

data class PlaybackSelection(
    val streamId: String,
    val video: VideoTrack?,
    val audio: AudioTrack,
    val resolved: ResolvedStreams,
    /**
     * User's manually selected quality height. Interpretation depends on [selectionOrigin]:
     * - AUTO/AUTO_RECOVERY → CAP mode: Maximum ceiling; ABR can drop below but not exceed
     * - MANUAL → LOCK mode: Fixed quality; no ABR switching
     *
     * null = AUTO mode (no constraint, ABR chooses freely)
     * non-null = User preference for resolution height
     *
     * @see QualityTrackSelector.applyQualityConstraint
     */
    val userQualityCapHeight: Int? = null,
    /**
     * The origin of the current selection. Used to distinguish manual user choices
     * from automatic recovery actions.
     *
     * Note: Quality constraint mode (CAP vs LOCK) is derived from this origin:
     * - MANUAL → LOCK mode (user explicitly selected resolution)
     * - AUTO/AUTO_RECOVERY → CAP mode (ABR can drop below but not exceed)
     *
     * @see PlayerFragment.applyQualityConstraintByOrigin
     */
    val selectionOrigin: QualitySelectionOrigin = QualitySelectionOrigin.AUTO
) {
    /**
     * For backward compatibility: returns true if user has manually set a quality constraint.
     * Use this when deciding whether to apply track selector constraints.
     */
    val hasUserQualityCap: Boolean
        get() = userQualityCapHeight != null
}
